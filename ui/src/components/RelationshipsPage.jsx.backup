import React, { useState, useEffect, useRef, useCallback } from 'react';
import axios from 'axios';
import * as d3 from 'd3';
import {
  Box,
  Grid,
  Card,
  CardContent,
  Typography,
  TextField,
  Button,
  List,
  ListItem,
  ListItemText,
  Chip,
  Paper,
  InputAdornment,
  Alert,
  Snackbar,
  Divider,
  IconButton,
  Tooltip
} from '@mui/material';
import {
  Search,
  X,
  ZoomIn,
  ZoomOut,
  RotateCcw,
  Maximize2,
  Info,
  Trash2
} from 'lucide-react';

const RelationshipsPage = ({
  apiEndpoint,
  apiKey,
  graphData,
  setGraphData,
  selectedEntity,
  setSelectedEntity,
  searchResults,
  setSearchResults
}) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [isLoadingEntity, setIsLoadingEntity] = useState(false);
  const [notification, setNotification] = useState({ open: false, message: '', severity: 'info' });
  const [expandedNodes, setExpandedNodes] = useState(new Set());
  const [highlightedNode, setHighlightedNode] = useState(null);

  const fgRef = useRef();
  const simulationRef = useRef();
  const headers = { headers: { 'x-api-key': apiKey } };

  const showNotification = (message, severity = 'info') => {
    setNotification({ open: true, message, severity });
  };

  // Get node color based on label
  const getNodeColor = (label) => {
    const colors = {
      'PERSON': '#FF6B6B',
      'ORGANIZATION': '#4ECDC4',
      'COMPANY': '#45B7D1',
      'LOCATION': '#96CEB4',
      'EVENT': '#FFEAA7',
      'PRODUCT': '#DDA0DD',
      'TECHNOLOGY': '#98D8C8'
    };
    return colors[label] || '#95A5A6';
  };

  // Load entity and its relationships
  const loadEntity = useCallback(async (entityId) => {
    if (!entityId || !apiEndpoint || !apiKey) return;

    setIsLoadingEntity(true);
    try {
      const response = await axios.get(`https://${apiEndpoint}/relationships`, {
        ...headers,
        params: { entity_id: entityId }
      });

      const { entity, relationships } = response.data;

      // Create nodes and links for the graph
      const nodes = new Map();
      const links = [];

      // Add the main entity
      nodes.set(entity.id, {
        id: entity.id,
        name: entity.name,
        label: entity.label,
        properties: entity.properties,
        relationshipCount: expandedNodes.has(entity.id) ? 0 : entity.relationship_count,
        isExpanded: expandedNodes.has(entity.id),
        isMainEntity: true,
        color: getNodeColor(entity.label),
        size: 12
      });

      // Collect new nodes for better initial positioning
      const newNodeIds = [];
      
      // Always add related entities and relationships when loading an entity
      relationships.forEach(rel => {
        // Add source node if not exists
        if (!nodes.has(rel.source.id)) {
          const isNewNode = !graphData.nodes.find(n => n.id === rel.source.id);
          if (isNewNode && rel.source.id !== entity.id) {
            newNodeIds.push(rel.source.id);
          }
          
          nodes.set(rel.source.id, {
            id: rel.source.id,
            name: rel.source.name,
            label: rel.source.label,
            relationshipCount: 0,
            isExpanded: false,
            isMainEntity: false,
            color: getNodeColor(rel.source.label),
            size: 8
          });
        }

        // Add target node if not exists
        if (!nodes.has(rel.target.id)) {
          const isNewNode = !graphData.nodes.find(n => n.id === rel.target.id);
          if (isNewNode && rel.target.id !== entity.id) {
            newNodeIds.push(rel.target.id);
          }
          
          nodes.set(rel.target.id, {
            id: rel.target.id,
            name: rel.target.name,
            label: rel.target.label,
            relationshipCount: 0,
            isExpanded: false,
            isMainEntity: false,
            color: getNodeColor(rel.target.label),
            size: 8
          });
        }

          // Add link
          links.push({
            source: rel.source.id,
            target: rel.target.id,
            label: rel.label,
            properties: rel.properties,
            id: rel.id
          });
        });

      // Merge with existing graph data
      const existingNodes = new Map(graphData.nodes.map(n => [n.id, n]));
      const existingLinks = [...graphData.links];

      // Position new nodes in a large circle around existing graph with better spacing
      const radius = Math.max(500, newNodeIds.length * 15);
      const angleStep = (2 * Math.PI) / Math.max(newNodeIds.length, 1);
      
      // Update or add nodes with initial positioning for new ones
      nodes.forEach((node, id) => {
        const existingNode = existingNodes.get(id);
        const newNodeIndex = newNodeIds.indexOf(id);
        
        if (newNodeIndex >= 0) {
          // Position new nodes in a circle with some randomization to prevent perfect alignment
          const angle = newNodeIndex * angleStep + (Math.random() - 0.5) * 0.2;
          const radiusVariation = radius + (Math.random() - 0.5) * 100;
          const initialX = Math.cos(angle) * radiusVariation;
          const initialY = Math.sin(angle) * radiusVariation;
          
          existingNodes.set(id, { 
            ...existingNode, 
            ...node,
            x: initialX,
            y: initialY,
            vx: (Math.random() - 0.5) * 50, // Add some initial velocity
            vy: (Math.random() - 0.5) * 50
          });
        } else {
          existingNodes.set(id, { ...existingNode, ...node });
        }
      });

      // Add new links (avoid duplicates)
      const existingLinkIds = new Set(existingLinks.map(l => `${l.source}-${l.target}-${l.label}`));
      links.forEach(link => {
        const linkId = `${link.source}-${link.target}-${link.label}`;
        if (!existingLinkIds.has(linkId)) {
          existingLinks.push(link);
        }
      });

      setGraphData({
        nodes: Array.from(existingNodes.values()),
        links: existingLinks
      });
      
      // Restart simulation with new nodes
      setTimeout(() => {
        if (simulationRef.current) {
          simulationRef.current.alpha(0.8).restart();
        }
      }, 100);

      setSelectedEntity(entity);
      setHighlightedNode(entity.id);
      showNotification(`Loaded ${entity.name} with ${relationships.length} relationships`, 'success');

    } catch (error) {
      console.error('Load entity error:', error);
      showNotification('Error loading entity relationships', 'error');
    }
    setIsLoadingEntity(false);
  }, [apiEndpoint, apiKey, headers, expandedNodes, getNodeColor, graphData.nodes, graphData.links, setGraphData, setSelectedEntity, setHighlightedNode, showNotification]);

  // Expand node relationships
  const expandNode = useCallback(async (nodeId) => {
    if (expandedNodes.has(nodeId)) return;

    const newExpandedNodes = new Set(expandedNodes);
    newExpandedNodes.add(nodeId);
    setExpandedNodes(newExpandedNodes);

    await loadEntity(nodeId);
  }, [expandedNodes, loadEntity]);

  // Handle node click
  const handleNodeClick = useCallback((node) => {
    if (!node.isExpanded && node.relationshipCount > 0) {
      expandNode(node.id);
    }
  }, [expandNode]);

  // Handle node double click
  const handleNodeDoubleClick = useCallback((node) => {
    expandNode(node.id);
  }, [expandNode]);

  // D3 Force-Directed Graph Implementation
  useEffect(() => {
    if (!fgRef.current || !graphData.nodes.length) return;

    const svg = d3.select(fgRef.current);
    const width = fgRef.current.clientWidth;
    const height = fgRef.current.clientHeight;

    // Clear previous content
    svg.selectAll("*").remove();

    // Create zoom behavior
    const zoom = d3.zoom()
      .scaleExtent([0.1, 10])
      .on("zoom", (event) => {
        container.attr("transform", event.transform);
      });

    svg.call(zoom);

    // Create container for graph elements
    const container = svg.append("g");

    // Create simulation with aggressive spacing
    const simulation = d3.forceSimulation(graphData.nodes)
      .force("link", d3.forceLink(graphData.links)
        .id(d => d.id)
        .distance(300)  // Large distance between connected nodes
        .strength(0.1)  // Weak link strength
      )
      .force("charge", d3.forceManyBody()
        .strength(-2000)  // Very strong repulsion
        .distanceMax(1000)  // Large repulsion range
      )
      .force("center", d3.forceCenter(width / 2, height / 2))
      .force("collision", d3.forceCollide()
        .radius(50)  // Large collision radius
        .strength(0.8)
      )
      .alphaDecay(0.01)  // Slow decay for longer simulation
      .velocityDecay(0.2);  // Low velocity decay

    simulationRef.current = simulation;

    // Create links
    const link = container.append("g")
      .selectAll("line")
      .data(graphData.links)
      .enter().append("line")
      .attr("stroke", "#BDC3C7")
      .attr("stroke-width", 2)
      .attr("marker-end", "url(#arrowhead)");

    // Create arrowhead marker
    svg.append("defs").append("marker")
      .attr("id", "arrowhead")
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 25)
      .attr("refY", 0)
      .attr("markerWidth", 6)
      .attr("markerHeight", 6)
      .attr("orient", "auto")
      .append("path")
      .attr("d", "M0,-5L10,0L0,5")
      .attr("fill", "#7F8C8D");

    // Create nodes
    const node = container.append("g")
      .selectAll("g")
      .data(graphData.nodes)
      .enter().append("g")
      .attr("class", "node")
      .call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended)
      );

    // Add circles to nodes with hover effects and highlighting
    node.append("circle")
      .attr("r", d => d.isMainEntity ? 15 : 10)
      .attr("fill", d => d.color)
      .attr("stroke", d => {
        if (highlightedNode && d.id === highlightedNode) return "#FF9900";
        return d.isMainEntity ? "#2C3E50" : "#34495E";
      })
      .attr("stroke-width", d => {
        if (highlightedNode && d.id === highlightedNode) return 4;
        return d.isMainEntity ? 3 : 1;
      })
      .style("cursor", "pointer")
      .on("click", (event, d) => handleNodeClick(d))
      .on("dblclick", (event, d) => handleNodeDoubleClick(d))
      .on("mouseover", function(event, d) {
        d3.select(this)
          .transition()
          .duration(200)
          .attr("r", d => (d.isMainEntity ? 15 : 10) * 1.2)
          .attr("stroke-width", d => {
            if (highlightedNode && d.id === highlightedNode) return 5;
            return (d.isMainEntity ? 3 : 1) * 1.5;
          });
      })
      .on("mouseout", function(event, d) {
        d3.select(this)
          .transition()
          .duration(200)
          .attr("r", d => d.isMainEntity ? 15 : 10)
          .attr("stroke-width", d => {
            if (highlightedNode && d.id === highlightedNode) return 4;
            return d.isMainEntity ? 3 : 1;
          });
      });

    // Add labels to nodes
    node.append("text")
      .text(d => d.name)
      .attr("x", 0)
      .attr("y", 25)
      .attr("text-anchor", "middle")
      .attr("font-size", "12px")
      .attr("font-family", "Arial, sans-serif")
      .attr("fill", "#2C3E50")
      .style("pointer-events", "none");

    // Add relationship count badges
    node.filter(d => d.relationshipCount > 0 && !d.isExpanded)
      .append("text")
      .text(d => `+${d.relationshipCount}`)
      .attr("x", 0)
      .attr("y", -20)
      .attr("text-anchor", "middle")
      .attr("font-size", "11px")
      .attr("font-weight", "bold")
      .attr("font-family", "Arial, sans-serif")
      .attr("fill", "#E74C3C")
      .style("pointer-events", "none");

    // Add link labels
    const linkLabel = container.append("g")
      .selectAll("text")
      .data(graphData.links)
      .enter().append("text")
      .text(d => d.label)
      .attr("font-size", "10px")
      .attr("font-family", "Arial, sans-serif")
      .attr("fill", "#34495E")
      .attr("text-anchor", "middle")
      .style("pointer-events", "none");

    // Update positions on simulation tick
    simulation.on("tick", () => {
      link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);

      node
        .attr("transform", d => `translate(${d.x},${d.y})`);

      linkLabel
        .attr("x", d => (d.source.x + d.target.x) / 2)
        .attr("y", d => (d.source.y + d.target.y) / 2);
    });

    // Auto-fit after simulation settles
    simulation.on("end", () => {
      setTimeout(() => {
        fitToView();
      }, 500);
    });

    // Drag functions
    function dragstarted(event, d) {
      if (!event.active) simulation.alphaTarget(0.3).restart();
      d.fx = d.x;
      d.fy = d.y;
    }

    function dragged(event, d) {
      d.fx = event.x;
      d.fy = event.y;
    }

    function dragended(event, d) {
      if (!event.active) simulation.alphaTarget(0);
      d.fx = null;
      d.fy = null;
    }

    // Fit to view function
    function fitToView() {
      if (!graphData.nodes.length) return;

      const bounds = container.node().getBBox();
      const fullWidth = width;
      const fullHeight = height;
      const widthScale = fullWidth / bounds.width;
      const heightScale = fullHeight / bounds.height;
      const scale = Math.min(widthScale, heightScale) * 0.8; // 80% to add padding

      const translate = [
        fullWidth / 2 - scale * (bounds.x + bounds.width / 2),
        fullHeight / 2 - scale * (bounds.y + bounds.height / 2)
      ];

      svg.transition()
        .duration(750)
        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
    }

    // Store fit function for external use
    fgRef.current.fitToView = fitToView;

    // Cleanup function
    return () => {
      if (simulationRef.current) {
        simulationRef.current.stop();
      }
    };

  }, [graphData, handleNodeClick, handleNodeDoubleClick, highlightedNode]);

  // Search for entities
  const handleSearch = async (term) => {
    if (!term.trim() || !apiEndpoint || !apiKey) return;

    setIsSearching(true);
    try {
      const response = await axios.get(`https://${apiEndpoint}/relationships`, {
        ...headers,
        params: { search: term.trim() }
      });

      setSearchResults(response.data);
      if (response.data.length === 0) {
        showNotification('No entities found matching your search', 'info');
      }
    } catch (error) {
      console.error('Search error:', error);
      showNotification('Error searching entities', 'error');
      setSearchResults([]);
    }
    setIsSearching(false);
  };





  // Clear graph
  const clearGraph = () => {
    setGraphData({ nodes: [], links: [] });
    setSelectedEntity(null);
    setExpandedNodes(new Set());
    setHighlightedNode(null);
    showNotification('Graph cleared', 'info');
  };

  // Graph controls
  const zoomIn = () => {
    if (fgRef.current) {
      const svg = d3.select(fgRef.current);
      const zoom = d3.zoom();
      svg.transition().duration(300).call(
        zoom.scaleBy, 1.5
      );
    }
  };
  
  const zoomOut = () => {
    if (fgRef.current) {
      const svg = d3.select(fgRef.current);
      const zoom = d3.zoom();
      svg.transition().duration(300).call(
        zoom.scaleBy, 0.75
      );
    }
  };
  
  const centerGraph = () => {
    if (fgRef.current && fgRef.current.fitToView) {
      fgRef.current.fitToView();
    }
  };
  
  // Force spread out nodes to prevent clustering
  const spreadNodes = () => {
    if (simulationRef.current && graphData.nodes.length > 1) {
      const simulation = simulationRef.current;
      const nodeCount = graphData.nodes.length;
      
      // Apply very strong repulsion temporarily
      simulation
        .force("charge", d3.forceManyBody()
          .strength(-5000)  // Much stronger repulsion
          .distanceMax(2000)
        )
        .force("collision", d3.forceCollide()
          .radius(80)  // Larger collision radius
          .strength(1.0)
        )
        .alpha(0.8)  // High energy
        .restart();
      
      // Reset to normal forces after spreading
      setTimeout(() => {
        simulation
          .force("charge", d3.forceManyBody()
            .strength(-2000)
            .distanceMax(1000)
          )
          .force("collision", d3.forceCollide()
            .radius(50)
            .strength(0.8)
          );
        
        // Fit to view after spreading
        setTimeout(() => {
          if (fgRef.current && fgRef.current.fitToView) {
            fgRef.current.fitToView();
          }
        }, 2000);
      }, 3000);
    }
  };



  return (
    <Box sx={{ maxWidth: 1200, mx: 'auto' }}>
      {/* Page Header */}
      <Typography variant="h4" sx={{ fontWeight: 600, color: 'primary.main', mb: 4 }}>
        Knowledge Graph Explorer
      </Typography>

      {/* Main Graph Visualization */}
      <Box sx={{ mb: 4 }}>
        <Card sx={{ height: 650, position: 'relative' }}>
          {/* Graph Header */}
          <Box sx={{
            p: 2,
            borderBottom: '1px solid #E9ECEF',
            display: 'flex',
            justifyContent: 'space-between',
            alignItems: 'center',
            backgroundColor: '#F8F9FA'
          }}>
            <Typography variant="h6" sx={{ fontWeight: 600, display: 'flex', alignItems: 'center', gap: 1 }}>
              <Search size={20} color="#FF9900" />
              Interactive Graph Visualization
            </Typography>

            {/* Quick Controls */}
            <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
              <Tooltip title="Zoom In">
                <IconButton size="small" onClick={zoomIn}>
                  <ZoomIn size={18} />
                </IconButton>
              </Tooltip>
              <Tooltip title="Zoom Out">
                <IconButton size="small" onClick={zoomOut}>
                  <ZoomOut size={18} />
                </IconButton>
              </Tooltip>
              <Tooltip title="Center Graph">
                <IconButton size="small" onClick={centerGraph}>
                  <Maximize2 size={18} />
                </IconButton>
              </Tooltip>
              <Tooltip title="Reset View">
                <IconButton size="small" onClick={centerGraph}>
                  <RotateCcw size={18} />
                </IconButton>
              </Tooltip>
              <Divider orientation="vertical" flexItem sx={{ mx: 1 }} />
              <Button
                variant="outlined"
                size="small"
                startIcon={<Trash2 size={16} />}
                onClick={clearGraph}
                disabled={graphData.nodes.length === 0}
                sx={{ textTransform: 'none', mr: 1 }}
              >
                Clear
              </Button>
              <Button
                variant="outlined"
                size="small"
                onClick={spreadNodes}
                disabled={graphData.nodes.length <= 1}
                sx={{ textTransform: 'none' }}
              >
                Spread
              </Button>
            </Box>
          </Box>

          {/* Loading Overlay */}
          {isLoadingEntity && (
            <Box sx={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              backgroundColor: 'rgba(255,255,255,0.9)',
              zIndex: 1000
            }}>
              <Box sx={{ textAlign: 'center' }}>
                <Typography variant="h6" sx={{ mb: 1 }}>Loading entity relationships...</Typography>
                <Typography variant="body2" color="text.secondary">Please wait while we fetch the data</Typography>
              </Box>
            </Box>
          )}

          {/* Graph Canvas */}
          <CardContent sx={{ height: 'calc(100% - 73px)', p: 0, position: 'relative' }}>
            <svg
              ref={fgRef}
              width="100%"
              height={577}
              style={{ backgroundColor: "#FFFFFF", cursor: "grab" }}
            />
            
            {/* Legend */}
            {graphData.nodes.length > 0 && (
              <Box sx={{
                position: 'absolute',
                top: 10,
                right: 10,
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                border: '1px solid #E9ECEF',
                borderRadius: 1,
                p: 1.5,
                minWidth: 150,
                boxShadow: '0 2px 8px rgba(0,0,0,0.1)'
              }}>
                <Typography variant="caption" sx={{ fontWeight: 600, mb: 1, display: 'block' }}>
                  Node Types
                </Typography>
                {Array.from(new Set(graphData.nodes.map(n => n.label))).map(label => (
                  <Box key={label} sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 0.5 }}>
                    <Box sx={{
                      width: 12,
                      height: 12,
                      borderRadius: '50%',
                      backgroundColor: getNodeColor(label),
                      border: '1px solid #34495E'
                    }} />
                    <Typography variant="caption" sx={{ fontSize: '0.7rem' }}>
                      {label}
                    </Typography>
                  </Box>
                ))}
                <Divider sx={{ my: 1 }} />
                <Typography variant="caption" sx={{ fontSize: '0.65rem', color: 'text.secondary' }}>
                  • Click to select<br/>
                  • Double-click to expand<br/>
                  • Drag to reposition
                </Typography>
              </Box>
            )}

            {/* Graph Stats */}
            {graphData.nodes.length > 0 && (
              <Box sx={{
                position: 'absolute',
                bottom: 10,
                left: 10,
                backgroundColor: 'rgba(255, 255, 255, 0.95)',
                border: '1px solid #E9ECEF',
                borderRadius: 1,
                p: 1,
                boxShadow: '0 2px 8px rgba(0,0,0,0.1)'
              }}>
                <Typography variant="caption" sx={{ fontSize: '0.7rem', color: 'text.secondary' }}>
                  {graphData.nodes.length} nodes • {graphData.links.length} relationships
                </Typography>
              </Box>
            )}
          </CardContent>
        </Card>
      </Box>

      {/* Bottom Section */}
      <Grid container spacing={4}>
        {/* Search & Discovery */}
        <Grid item xs={12} md={6}>
          <Typography variant="h6" sx={{ fontWeight: 600, mb: 2, display: 'flex', alignItems: 'center', gap: 1 }}>
            <Search size={18} color="#FF9900" />
            Entity Search & Discovery
          </Typography>

          <Card>
            <CardContent>

              <TextField
                fullWidth
                size="small"
                placeholder="Search for entities in the knowledge graph..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                onKeyPress={(e) => e.key === 'Enter' && handleSearch(searchTerm)}
                InputProps={{
                  startAdornment: (
                    <InputAdornment position="start">
                      <Search size={18} color="#666" />
                    </InputAdornment>
                  ),
                  endAdornment: searchTerm && (
                    <InputAdornment position="end">
                      <IconButton size="small" onClick={() => setSearchTerm('')}>
                        <X size={16} />
                      </IconButton>
                    </InputAdornment>
                  )
                }}
                sx={{
                  mb: 2,
                  '& .MuiOutlinedInput-root': {
                    '&.Mui-focused fieldset': {
                      borderColor: 'primary.main',
                    },
                  },
                }}
              />

              <Button
                fullWidth
                variant="contained"
                onClick={() => handleSearch(searchTerm)}
                disabled={isSearching || !searchTerm.trim()}
                sx={{ mb: 2, textTransform: 'none' }}
              >
                {isSearching ? 'Searching...' : 'Search Entities'}
              </Button>

              {/* Search Results */}
              {searchResults.length > 0 && (
                <Paper sx={{
                  maxHeight: 250,
                  overflow: 'auto',
                  border: '1px solid #E9ECEF'
                }}>
                  <List dense sx={{ p: 0 }}>
                    {searchResults.map((entity, index) => (
                      <ListItem
                        key={entity.ID}
                        component="button"
                        onClick={() => loadEntity(entity.ID)}
                        disabled={isLoadingEntity}
                        sx={{
                          borderBottom: index < searchResults.length - 1 ? '1px solid #F1F3F4' : 'none',
                          py: 1.5,
                          '&:hover': { backgroundColor: '#F8F9FA' }
                        }}
                      >
                        <ListItemText
                          primary={
                            <Typography variant="subtitle2" sx={{ fontWeight: 500 }}>
                              {entity.NAME}
                            </Typography>
                          }
                          secondary={
                            <Chip
                              label={entity.LABEL}
                              size="small"
                              variant="outlined"
                              sx={{
                                borderColor: getNodeColor(entity.LABEL),
                                color: getNodeColor(entity.LABEL),
                                fontSize: '0.7rem',
                                mt: 0.5
                              }}
                            />
                          }
                        />
                      </ListItem>
                    ))}
                  </List>
                </Paper>
              )}

              {searchResults.length === 0 && searchTerm && !isSearching && (
                <Alert severity="info" sx={{ mt: 1 }}>
                  No entities found matching "{searchTerm}". Try a different search term.
                </Alert>
              )}
            </CardContent>
          </Card>

        </Grid>

        {/* Entity Details & Instructions */}
        <Grid item xs={12} md={6}>
          <Typography variant="h6" sx={{ fontWeight: 600, mb: 2, display: 'flex', alignItems: 'center', gap: 1 }}>
            <Info size={18} color="#FF9900" />
            {selectedEntity ? 'Selected Entity Details' : 'How to Use'}
          </Typography>

          <Card>
            <CardContent>
              {selectedEntity ? (
                <Box>
                  <Typography variant="h6" sx={{ mb: 2, color: 'primary.main' }}>
                    {selectedEntity.name}
                  </Typography>

                  <Box sx={{ display: 'flex', gap: 1, mb: 2 }}>
                    <Chip
                      label={selectedEntity.label}
                      sx={{
                        backgroundColor: getNodeColor(selectedEntity.label),
                        color: 'white',
                        fontWeight: 500
                      }}
                    />
                  </Box>

                  {Object.keys(selectedEntity.properties).length > 0 && (
                    <Box>
                      <Typography variant="subtitle2" sx={{ mb: 1, fontWeight: 600 }}>
                        Properties:
                      </Typography>
                      <Paper sx={{ p: 2, backgroundColor: '#F8F9FA' }}>
                        {Object.entries(selectedEntity.properties).map(([key, value]) => (
                          <Typography key={key} variant="body2" sx={{ mb: 1 }}>
                            <strong>{key.replace(/_/g, ' ')}:</strong> {value}
                          </Typography>
                        ))}
                      </Paper>
                    </Box>
                  )}
                </Box>
              ) : (
                <Box>
                  <Typography variant="body1" sx={{ mb: 2, fontWeight: 500 }}>
                    Welcome to the Knowledge Graph Explorer!
                  </Typography>

                  <Box sx={{ mb: 2 }}>
                    <Typography variant="body2" sx={{ mb: 1, display: 'flex', alignItems: 'center', gap: 1 }}>
                      <span style={{
                        width: 8,
                        height: 8,
                        borderRadius: '50%',
                        backgroundColor: '#FF9900',
                        display: 'inline-block'
                      }}></span>
                      <strong>Search:</strong> Use the search box to find entities
                    </Typography>
                    <Typography variant="body2" sx={{ mb: 1, display: 'flex', alignItems: 'center', gap: 1 }}>
                      <span style={{
                        width: 8,
                        height: 8,
                        borderRadius: '50%',
                        backgroundColor: '#FF9900',
                        display: 'inline-block'
                      }}></span>
                      <strong>Click:</strong> Select entities from search results
                    </Typography>
                    <Typography variant="body2" sx={{ mb: 1, display: 'flex', alignItems: 'center', gap: 1 }}>
                      <span style={{
                        width: 8,
                        height: 8,
                        borderRadius: '50%',
                        backgroundColor: '#FF9900',
                        display: 'inline-block'
                      }}></span>
                      <strong>Double-click:</strong> Expand node relationships
                    </Typography>
                    <Typography variant="body2" sx={{ mb: 1, display: 'flex', alignItems: 'center', gap: 1 }}>
                      <span style={{
                        width: 8,
                        height: 8,
                        borderRadius: '50%',
                        backgroundColor: '#FF9900',
                        display: 'inline-block'
                      }}></span>
                      <strong>Drag:</strong> Move nodes around for better visualization
                    </Typography>
                  </Box>

                  <Alert severity="info" sx={{ mt: 2 }}>
                    Red badges on nodes indicate unexplored relationships. Double-click to expand!
                  </Alert>
                </Box>
              )}
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      <Snackbar
        open={notification.open}
        autoHideDuration={6000}
        onClose={() => setNotification({ ...notification, open: false })}
      >
        <Alert
          onClose={() => setNotification({ ...notification, open: false })}
          severity={notification.severity}
          sx={{ width: '100%' }}
        >
          {notification.message}
        </Alert>
      </Snackbar>
    </Box>
  );
};

export default RelationshipsPage;